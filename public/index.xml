<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>My Musings</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on My Musings</description>
    <generator>Hugo -- 0.140.2</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 28 Jul 2024 00:24:13 +0530</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Birthday Paradox</title>
      <link>http://localhost:1313/blog/birthday-paradox/</link>
      <pubDate>Sun, 28 Jul 2024 00:24:13 +0530</pubDate>
      <guid>http://localhost:1313/blog/birthday-paradox/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;
&lt;p&gt;This is going to be a quick blogpost on the &lt;a href=&#34;https://en.wikipedia.org/wiki/Birthday_problem&#34;&gt;birthday paradox&lt;/a&gt;. This is a famous probability theory problem, which asks for the probability that, in a set of n randomly chosen people, at least two will share a birthday.
This is called a paradox and for a good reason. The solution to this problem is very counter-intuitive. This blog post is going to be an attempt to use some computer science and maths to analyze this problem and figure out why this is called a paradox.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Exploring TCP and Quic</title>
      <link>http://localhost:1313/blog/tcp-quic/</link>
      <pubDate>Sun, 26 May 2024 00:24:13 +0530</pubDate>
      <guid>http://localhost:1313/blog/tcp-quic/</guid>
      <description>&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;
&lt;p&gt;I recently delved into the TCP protocol for network communication, finding it a fascinating exploration of its origins in the 1970s and its enduring role as the backbone of the internet. While TCP continues to be widely utilized, a newcomer named QUIC has emerged in recent years, touted for its enhanced efficiency compared to TCP. Many browsers and websites have already embraced QUIC, signaling a potential shift in the landscape of network protocols. But what sets QUIC apart from TCP?&lt;/p&gt;</description>
    </item>
    <item>
      <title>Diffie Hellman Key Exchange</title>
      <link>http://localhost:1313/blog/diffie-hellman/</link>
      <pubDate>Fri, 03 Feb 2023 00:24:13 +0530</pubDate>
      <guid>http://localhost:1313/blog/diffie-hellman/</guid>
      <description>&lt;p&gt;Recently I had the opportunity to read about the Diffie Hellman key exchange and found it to be fascinating. The beauty of it lies in its simplicity. Of course there is some complicated number theory involved, but overall it is pretty easy to grasp the concept intuitively as well. So let&amp;rsquo;s start with it&amp;hellip;&lt;/p&gt;
&lt;h2 id=&#34;what&#34;&gt;What?&lt;/h2&gt;
&lt;p&gt;Diffie-Hellman key exchange is a method of digital encryption that securely exchanges cryptographic keys between two parties over a public channel without their conversation being transmitted over the internet. The two parties use symmetric cryptography to encrypt and decrypt their messages. Published in 1976 by Whitfield Diffie and Martin Hellman, it was one of the first practical examples of public key cryptography.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Year in books - 2022</title>
      <link>http://localhost:1313/blog/bookreview2022/</link>
      <pubDate>Fri, 30 Dec 2022 00:24:13 +0530</pubDate>
      <guid>http://localhost:1313/blog/bookreview2022/</guid>
      <description>&lt;p&gt;In the January of the year 2022, I thought of setting a goal for myself with regards to the number of books I read in a year. During my school days, I was an avid reader and was very interested in reading fiction. However, with the JEE preparation (starting from class 11th) most of that stopped. Since then, I have read multiple books on and off but never got into a habit of reading regularly.
I thought a target of reading 25 books in the year although a little ambitious, might be a decent one. I had not decided on a book list or anything but wanted to focus on non-fiction. Over the years I find myself more fullfilled if I read a non-fiction book rather than a fiction one.
I watched a few youtube videos and found an interesting advice about the art of reading which I was not aware of earlier which holds true for non-fiction. Most of the non-fiction books could be condensed into a blog post. They have a few points which the author wants to drive home and then they try to drill those points in the mind of the readers using various techniques/stories. So for non-fiction books, it generally doesn&amp;rsquo;t make sense to read them cover to cover.
This concept is something I am still wrapping my head around. I am accustomed to reading books without skipping any page even if it is done for a formality. However, I quickly realised that this practice is really hard to keep up for non-fiction. They are generally not as gripping as fiction. In fact, people also suggest to simply skip over chapters you don&amp;rsquo;t want to read in non-fiction. This is something I still can&amp;rsquo;t do. However, I guess I have got pretty good at skipping over paragraphs/pages I don&amp;rsquo;t find particularly engaging.
Another very powerful concept, which I believe I agree with, but still haven&amp;rsquo;t accepted fully is that it is the duty of an author to capture your attention for the entire duration of the book. If they are not able to do so, you can just put the book down and not read it. You are not obligated to read it.
One thing that I have realised however is that not all books can be read at all points in your life. Some books only make sense when their time has come and when you are ready for them. So it is ok to not read a book until you feel ready for it.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Infinite Queens</title>
      <link>http://localhost:1313/blog/infinitequeens/</link>
      <pubDate>Wed, 30 Nov 2022 00:24:13 +0530</pubDate>
      <guid>http://localhost:1313/blog/infinitequeens/</guid>
      <description>&lt;p&gt;There is a very interesting set of events that led me to this topic. And boy am I glad that I stumbled on this. I had a lot of fun working on this and it definitely warrants a blog post. So here it goes&amp;hellip;&lt;/p&gt;
&lt;h2 id=&#34;backstory&#34;&gt;Backstory&lt;/h2&gt;
&lt;p&gt;I am reading the book &lt;strong&gt;Algorithms to Live By&lt;/strong&gt; (a great book so far btw). In that book, there is a mention of how to manage time like a CPU Scheduler and not do too many context switches as it can affect your productivity adversely. The author mentions &lt;a href=&#34;https://en.wikipedia.org/wiki/Donald_Knuth&#34;&gt;Donald Knuth&lt;/a&gt; who is a very famous computer scientist probably most famous for his book series - &lt;strong&gt;The Art Of Computer Programming&lt;/strong&gt;. It was mentioned how he maintains his project &lt;a href=&#34;https://en.wikipedia.org/wiki/TeX&#34;&gt;TEX&lt;/a&gt; and since the software is relatively stable, he does a bug fix for it every 6 years and no sooner. The author mentions how he is an embodiment of minimal context switching lifestyle and focussing on just one thing at once. This is another topic of debate but not of interest in this blog post. I already knew about Knuth but just out of curiosity I searched around a bit and found &lt;a href=&#34;https://www.youtube.com/playlist?list=PLoROMvodv4rOAvKVR_dyCigSBMcYjevYB&#34;&gt;these&lt;/a&gt;: &lt;strong&gt;Donald Knuth Christmas Lectures at Stanford&lt;/strong&gt;. I started watching the 2017 lecture, &lt;a href=&#34;https://www.youtube.com/watch?v=BxQw4CdxLr8&amp;amp;list=PLoROMvodv4rOAvKVR_dyCigSBMcYjevYB&amp;amp;index=3&#34;&gt;A Conjecture That Had To Be True&lt;/a&gt; and even though the primary focus of the lecture was on a different problem (which was also pretty interesting), what caught my eye was something he mentioned at around the end of the lecture. The infinite queens problem. As much as I would like to continue this story, I think it would be better to just get into the technical details and see what this is all about.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Evaluating million digits of Pi</title>
      <link>http://localhost:1313/blog/pievaluator/</link>
      <pubDate>Tue, 16 Aug 2022 00:24:13 +0530</pubDate>
      <guid>http://localhost:1313/blog/pievaluator/</guid>
      <description>&lt;p&gt;I recently got inspired from a book I am reading, Fermat&amp;rsquo;s Last Theorem by Simon Singh, and decided to see what it takes to evaulate Pi to a large number of decimal places. I though that a million would be a good starting point, so a day later, here we are.&lt;/p&gt;
&lt;p&gt;Now obviously, there is a lot of material out there on this as this seems to be a topic of great interest for a lot of people. I definitely find this fascinating but I also believe that there is no significance or meaning attached to the digits of pi. It is just a random string of numbers. However, I think this is true in mathematics as well as life that the things you have the most fun in doing eventually turns out to be those which you didn&amp;rsquo;t do for some material gain.&lt;/p&gt;</description>
    </item>
    <item>
      <title>The Internals of SHA 256 Algorithm</title>
      <link>http://localhost:1313/blog/sha256/</link>
      <pubDate>Sun, 26 Jun 2022 12:09:25 +0530</pubDate>
      <guid>http://localhost:1313/blog/sha256/</guid>
      <description>&lt;p&gt;I came across &lt;a href=&#34;https://www.youtube.com/watch?v=f9EbD6iY9zI&#34;&gt;this&lt;/a&gt; excellent video, explaining how the &lt;a href=&#34;https://en.wikipedia.org/wiki/SHA-2&#34;&gt;SHA-256&lt;/a&gt; algorithm works internally. I had always been excited to understand how a real-world hashing algorithm works internally. SHA-256 is one of the most popular hashing algorithms, so after getting my hands on that video, I knew I had to try and implement this on my own. This feels like once in a lifetime opportunity. So here I am after having implemented the algorithm on my own and feeling confident understanding how SHA-256 works. I want to pass on that same confidence to the readers of this blog (probably including me in a few months :D) along with code snippets. So, lets dive right into it&amp;hellip;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Consistent Hashing</title>
      <link>http://localhost:1313/blog/consistent-hashing/</link>
      <pubDate>Wed, 22 Jun 2022 12:09:25 +0530</pubDate>
      <guid>http://localhost:1313/blog/consistent-hashing/</guid>
      <description>&lt;p&gt;I have been meaning to write this blog for some time now but somehow kept on postponing (read procrastinating&amp;hellip;). I read about this technique of Consistent Hashing a while back and was mesmerized by its elegance. Recently read it again in this brilliant blog and thought of expressing it in my own words for posterity. So let us begin.&lt;/p&gt;
&lt;h3 id=&#34;hashing&#34;&gt;Hashing&lt;/h3&gt;
&lt;p&gt;I won&amp;rsquo;t talk too much about hashing since it is a very basic computer science concept. In a word, it means mapping an object to another object. Or more generally, mapping a key to a value where their types don&amp;rsquo;t matter. Mostly the mapping is from a string to int.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Book Review: Atomic Habits</title>
      <link>http://localhost:1313/blog/atomic-habits/</link>
      <pubDate>Fri, 28 Jan 2022 12:09:25 +0530</pubDate>
      <guid>http://localhost:1313/blog/atomic-habits/</guid>
      <description>&lt;p&gt;I recently completed this wonderful book by James Clear, &lt;a href=&#34;https://www.amazon.in/Atomic-Habits-James-Clear/dp/1847941834/ref=asc_df_1847941834/?tag=googleshopdes-21&amp;amp;linkCode=df0&amp;amp;hvadid=396987849297&amp;amp;hvpos=&amp;amp;hvnetw=g&amp;amp;hvrand=5229243871160487523&amp;amp;hvpone=&amp;amp;hvptwo=&amp;amp;hvqmt=&amp;amp;hvdev=c&amp;amp;hvdvcmdl=&amp;amp;hvlocint=&amp;amp;hvlocphy=1007820&amp;amp;hvtargid=pla-551566274852&amp;amp;psc=1&amp;amp;ext_vrnc=hi&#34;&gt;Atomic Habits&lt;/a&gt;. More than a book review, this is going to be a compilation of the learnings that I have from this book. The book is such a vast treasure chest of information that it is very easy to forget all of it. Even writing it down is probably not enough. The actual value of the book will come from the application of the concepts it teaches in our everyday life. But, to start things off, here goes my learnings from this great book.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Zookeeper Internals</title>
      <link>http://localhost:1313/blog/zookeeper/</link>
      <pubDate>Wed, 21 Jul 2021 12:09:25 +0530</pubDate>
      <guid>http://localhost:1313/blog/zookeeper/</guid>
      <description>&lt;p&gt;I had been wanting to understand the internals of zookeeper for quite some time now. In fact, I had already read the basics a couple of times and even worked with the zkcli in my previous organization. However, as it is said that anything written down is more firmly impressed on the mind, hence I am writing this post. (This also has a reference to one of my favorite magician - &lt;a href=&#34;https://www.youtube.com/watch?v=F8KFMUdrikM&amp;amp;t=830s&#34;&gt;Michael Vincent&lt;/a&gt;)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Some Mysteries of Multi-Threading</title>
      <link>http://localhost:1313/blog/multi-thread/</link>
      <pubDate>Fri, 02 Apr 2021 12:09:25 +0530</pubDate>
      <guid>http://localhost:1313/blog/multi-thread/</guid>
      <description>&lt;p&gt;If you have been programming professionally for some time, you probably would have used threads. When used correctly, threads can provide significant speed up in the program.&lt;/p&gt;
&lt;p&gt;I had also written multithreaded programs many times at Sumo Logic. However, recently I felt that since threading is such an important topic, I should probably dive a little deeper into how things work there.&lt;/p&gt;
&lt;p&gt;I started off by reading &lt;a href=&#34;https://www.amazon.in/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601&#34;&gt;Java Concurrency in Practice&lt;/a&gt; and although I have gone through only a couple of chapters right now, but still I have discovered some interesting things which I was not aware of before.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Euclids GCD Algorithm</title>
      <link>http://localhost:1313/blog/euclid-gcd-algo/</link>
      <pubDate>Mon, 08 Mar 2021 12:09:25 +0530</pubDate>
      <guid>http://localhost:1313/blog/euclid-gcd-algo/</guid>
      <description>&lt;p&gt;This post is going to focus on a very simple concept, finding the &lt;a href=&#34;https://en.wikipedia.org/wiki/Greatest_common_divisor#:~:text=In%20mathematics%2C%20the%20greatest%20common,divides%20each%20of%20the%20integers&#34;&gt;GCD&lt;/a&gt; of two numbers. If you think this is too easy and we don&amp;rsquo;t need a post on it, well you are probably right :D. You might even be knowing of efficient ways of finding the GCD (mostly used in competitive programming). But many of you may not be aware of the mathematics and proof behind how that method works. If that is the case, you are not alone. I was in the same boat for many years. I have used that &lt;a href=&#34;https://en.wikipedia.org/wiki/Euclidean_algorithm#Implementations&#34;&gt;3 line GCD&lt;/a&gt; method many times in solving programming questions never thinking deeply about why it works. There is no issue in this. After all there is a good reason why abstraction is so popular. But I do believe that when you get a chance there is no harm in diving deep. You may get to learn a few things and as always be fascinated by what math has to offer even in the simplest of concepts. So lets begin&amp;hellip;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Deduping at Scale</title>
      <link>http://localhost:1313/blog/deduping-at-scale/</link>
      <pubDate>Sun, 29 Nov 2020 12:09:25 +0530</pubDate>
      <guid>http://localhost:1313/blog/deduping-at-scale/</guid>
      <description>&lt;p&gt;Today I am going to talk about a project which I worked on in my organisation &lt;a href=&#34;https://www.sumologic.com/&#34;&gt;Sumo Logic&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We have this microservice which is used for collecting data from the cloud. One of the most prominent &lt;a href=&#34;https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/AWS-S3-Source&#34;&gt;use case&lt;/a&gt; of that microservice is to collect data from customers S3 bucket.&lt;/p&gt;
&lt;p&gt;I have written another blog on how we worked on making data discovery faster so that we can reduce ingestion lag. You can check it out &lt;a href=&#34;https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/AWS-S3-Source&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Detecting starting point of loop in a linked list</title>
      <link>http://localhost:1313/blog/starting-point-linked-list/</link>
      <pubDate>Thu, 06 Jun 2019 12:01:25 +0530</pubDate>
      <guid>http://localhost:1313/blog/starting-point-linked-list/</guid>
      <description>&lt;p&gt;Detecting the starting point of a loop in a linked list is a very popular problem. In fact most you reading this might already be knowing the algorithm to solve this. However understanding why that algorithm works is a separate challenge altogether.&lt;/p&gt;
&lt;p&gt;I was in the same state and decided to find an explanation of why it works. I could not find convincing explanations by simple google searches and hence decided to right this blog.
Hopefully, this will satisfy the curiosity of people trying to understand the reasoning behind this algorithm.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Fermats Little Theorem</title>
      <link>http://localhost:1313/blog/fermats-little-theorem/</link>
      <pubDate>Thu, 08 Jun 2017 12:09:25 +0530</pubDate>
      <guid>http://localhost:1313/blog/fermats-little-theorem/</guid>
      <description>&lt;p&gt;In my post on RSA encryption system I mentioned the use of Fermat&amp;rsquo;s little theorem. In this post I am going to give a formal proof (and explain in simple terms) the theorem itself. This will also give you a chance to boast among your friends (possibly nerdy) that you know the proof to one of Fermat’s theorem ;)&lt;/p&gt;
&lt;h3 id=&#34;the-statement&#34;&gt;THE STATEMENT&lt;/h3&gt;
&lt;p&gt;Fermat&amp;rsquo;s little theorem states that:
For any integer a not divisible by p and any prime p, the following always holds: a(p-1) ≡ 1 (mod p)
The reason why the theorem states that a should not be divisible by p is very clear. Let us assume that a was divisible by p, then obviously p will divide a(p-1).
So this means that a&lt;!-- raw HTML omitted --&gt;(p-1)&lt;!-- raw HTML omitted --&gt; ≡ 0 (mod p) when p | a. So this is an exception and is separately mentioned in the theorem.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Chinese Remainder Theorem</title>
      <link>http://localhost:1313/blog/chinese-remainder-theorem/</link>
      <pubDate>Wed, 26 Apr 2017 12:09:25 +0530</pubDate>
      <guid>http://localhost:1313/blog/chinese-remainder-theorem/</guid>
      <description>&lt;p&gt;In this post I would like to talk about the Chinese Remainder Theorem. You might have heard this problem as a kid: &lt;strong&gt;There are x number of things. When taken in groups of 5, they leave a remainder 1. When taken in groups of 7, they leave a remainder 2. When taken in groups of 9, they leave a remainder 3. And when taken in groups of 11, they leave a remainder 4. Find the value of x.&lt;/strong&gt; We will see how such problems can be solved using the Chinese Remainder Theorem(CRT).&lt;/p&gt;</description>
    </item>
    <item>
      <title>RSA Encryption System</title>
      <link>http://localhost:1313/blog/rsa-encryption/</link>
      <pubDate>Sat, 22 Apr 2017 12:09:25 +0530</pubDate>
      <guid>http://localhost:1313/blog/rsa-encryption/</guid>
      <description>&lt;h3 id=&#34;the-need-of-encryption&#34;&gt;THE NEED OF ENCRYPTION&lt;/h3&gt;
&lt;p&gt;In today&amp;rsquo;s world where a lot of secured information like our credit card number, passwords etc., travel around the web, the presence of a secure encryption system is almost inevitable.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;We want a method to encrypt a message, send it over the insecure internet connection and allow only the receiver to be able to decrypt and read the original message.&lt;/strong&gt; This exact problem was solved by Rivest, Shamir and Adleman(RSA) in the year 1978, in their paper A Method for Obtaining Digital Signatures and Public-Key Cryptosystems.
In this post, I will try to explain the method they adopted to create a secure encryption system.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Max Flow Min Cut</title>
      <link>http://localhost:1313/blog/max-flow-min-cut/</link>
      <pubDate>Fri, 21 Apr 2017 12:09:25 +0530</pubDate>
      <guid>http://localhost:1313/blog/max-flow-min-cut/</guid>
      <description>&lt;p&gt;PS: The images in this blogpost were hosted on a site which was taken down so they are lost and I don&amp;rsquo;t remember where I took them originally from so this is hard to read right now. Have to fix this in future.&lt;/p&gt;
&lt;h3 id=&#34;min-cut&#34;&gt;MIN CUT&lt;/h3&gt;
&lt;p&gt;We have already talked about the maximum flow problem. Now is a good time to talk about a seemingly different but actually quite similar to the maximum flow problem, i.e the min-cut problem.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Maximum Flow</title>
      <link>http://localhost:1313/blog/max-flow/</link>
      <pubDate>Wed, 19 Apr 2017 12:09:25 +0530</pubDate>
      <guid>http://localhost:1313/blog/max-flow/</guid>
      <description>&lt;h3 id=&#34;problem-description&#34;&gt;PROBLEM DESCRIPTION&lt;/h3&gt;
&lt;p&gt;The problem of finding the maximum flow in a network, has a history which dates back to the second world war.&lt;/p&gt;
&lt;p&gt;Practically the maximum flow problem can be stated as:
“A list of pipes is given, with different flow-capacities. These pipes are connected at their endpoints. What is the maximum amount of water that you can route from a given starting point to a given ending point?” or equivalently “A company owns a factory located in city X where products are manufactured that need to be transported to the distribution center in city Y. You are given the one-way roads that connect pairs of cities in the country, and the maximum number of trucks that can drive along each road. What is the maximum number of trucks that the company can send to the distribution center?”&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
